<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huamuyichun.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="AFL源码阅读是学习AFL工具的最好方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL源码阅读">
<meta property="og:url" content="http://huamuyichun.github.io/2024/03/01/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.html">
<meta property="og:site_name" content="hmyc_blog">
<meta property="og:description" content="AFL源码阅读是学习AFL工具的最好方法。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-01T14:49:14.000Z">
<meta property="article:modified_time" content="2024-03-03T04:01:57.716Z">
<meta property="article:author" content="Sparrow">
<meta property="article:tag" content="AFL">
<meta property="article:tag" content="模糊测试">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://huamuyichun.github.io/2024/03/01/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>AFL源码阅读 | hmyc_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hmyc_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huamuyichun.github.io/2024/03/01/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparrow">
      <meta itemprop="description" content="不知所措才是人生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmyc_blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AFL源码阅读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-01 22:49:14" itemprop="dateCreated datePublished" datetime="2024-03-01T22:49:14+08:00">2024-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-03 12:01:57" itemprop="dateModified" datetime="2024-03-03T12:01:57+08:00">2024-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/cs/" itemprop="url" rel="index"><span itemprop="name">cs</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/cs/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/cs/%E6%B5%8B%E8%AF%95/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">模糊测试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/cs/%E6%B5%8B%E8%AF%95/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>AFL源码阅读是学习AFL工具的最好方法。</p>
<span id="more"></span>
<p>这是笔者第一次独立阅读中规模代码，可能会有所疏漏。<br>由于使用的学习流是ob，所以会出现一定的双链，可以对着Q&amp;A看，懒得再修改了。</p>
<h1 id="afl-gcc-c"><a href="#afl-gcc-c" class="headerlink" title="afl-gcc.c"></a>afl-gcc.c</h1><h3 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h3><p>这个函数用来[[Q&amp;A#为什么要找afl-as的位置以及找到它之后的用途|寻找afl-as可执行文件的位置]]<br>寻找<code>afl-as</code>的位置是为了确定系统中<code>afl-as</code>可执行文件的路径，它是一个用于插桩二进制文件的汇编器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">find_as</span><span class="params">(u8* argv0)</span> &#123;</span><br><span class="line">  u8 *afl_path = getenv(<span class="string">&quot;AFL_PATH&quot;</span>);<span class="comment">//尝试获取环境变量的值</span></span><br><span class="line">  u8 *slash, *tmp;</span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/as&quot;</span>, afl_path);</span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = afl_path;</span><br><span class="line">      ck_free(tmp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ck_free(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (slash) &#123;</span><br><span class="line">    u8 *dir;</span><br><span class="line">    *slash = <span class="number">0</span>;</span><br><span class="line">    dir = ck_strdup(argv0);</span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/afl-as&quot;</span>, dir);</span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = dir;</span><br><span class="line">      ck_free(tmp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ck_free(tmp);</span><br><span class="line">    ck_free(dir);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!access(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123;</span><br><span class="line">    as_path = AFL_PATH;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FATAL(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过不同的方法去找<code>afl-as</code>的位置。这样的设计是为了确保afl工具能找到这个汇编器。</p>
<h3 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h3><p>这个函数是将[[Q&amp;A#argv是什么|<code>argv</code>]]拷贝到<code>cc_params</code>，然后进行相应的处理<br>函数本体并无特点</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>实际上，<code>afl-gcc</code>就是找到<code>as</code>所在位置，将其加入搜索路径，然后设置必要的gcc参数和一些宏，然后调用gcc进行实际的编译，仅仅是一层<code>wrapper</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);<span class="comment">//查找fake GNU assembler</span></span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);<span class="comment">//设置CC的参数</span></span><br><span class="line"></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);<span class="comment">//调用execvp执行CC</span></span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">[&lt;<span class="number">64</span>;<span class="number">50</span>;<span class="number">20</span>M```</span><br><span class="line">也就是说，`afl-gcc`其实本身逻辑很简单</span><br><span class="line">[&lt;<span class="number">64</span>;<span class="number">50</span>;<span class="number">20</span>M</span><br><span class="line">[&lt;<span class="number">64</span>;<span class="number">49</span>;<span class="number">20</span>M<span class="meta"># afl-as.c</span></span><br><span class="line">### 变量定义</span><br><span class="line">[&lt;<span class="number">64</span>;<span class="number">49</span>;<span class="number">20</span>M```c</span><br><span class="line"><span class="type">static</span> u8** as_params;          <span class="comment">/* Parameters passed to the real &#x27;as&#x27;</span></span><br><span class="line"><span class="comment">[&lt;64;49;20M传递给as的参数*/</span></span><br><span class="line"></span><br><span class="line">[&lt;<span class="number">64</span>;<span class="number">49</span>;<span class="number">20</span>Mstatic u8*  input_file;         <span class="comment">/* Originally specified input file</span></span><br><span class="line"><span class="comment">输入文件*/</span></span><br><span class="line"><span class="type">static</span> u8*  modified_file;      <span class="comment">/* Instrumented file for the real &#x27;as&#x27;</span></span><br><span class="line"><span class="comment">as进行插桩处理的文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8   be_quiet,           <span class="comment">/* Quiet mode (no stderr output)</span></span><br><span class="line"><span class="comment">静默模式，没有标准输出*/</span></span><br><span class="line">            clang_mode,         <span class="comment">/* Running in clang mode?               */</span></span><br><span class="line">            pass_thru,          <span class="comment">/* Just pass data through?              */</span></span><br><span class="line">            just_version,       <span class="comment">/* Just show version?                   */</span></span><br><span class="line">            sanitizer;          <span class="comment">/* Using ASAN / MSAN                    */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32  inst_ratio = <span class="number">100</span>,   <span class="comment">/* Instrumentation probability (%)</span></span><br><span class="line"><span class="comment">插桩覆盖率*/</span></span><br><span class="line">            as_par_cnt = <span class="number">1</span>;     <span class="comment">/* Number of params to &#x27;as&#x27;</span></span><br><span class="line"><span class="comment">传递给as的参数数量初始值*/</span></span><br></pre></td></tr></table></figure>

<h3 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h3><p>检查并修改参数以传递给<code>as</code>。请注意，文件名始终是GCC传递的最后一个参数，因此我们利用这个特性使代码保持简单。<br><strong>主要是设置变量as_params的值，以及use_64bit&#x2F;modified_file的值。</strong></p>
<h3 id="add-instructmentation"><a href="#add-instructmentation" class="headerlink" title="add_instructmentation"></a>add_instructmentation</h3><p>处理输入文件，生成<code>modified_file</code>将桩插入到适当的位置<br>在这里，<code>outf</code>即为输出文件的指针<br>这一部分是文件I&#x2F;O处理</p>
<ul>
<li>如果input_file不为空，则尝试打开这个文件，如果打开失败就抛出异常，如果为空，则读取标准输入，最终获取FILE* 指针inf</li>
<li>然后打开modified_file对应的临时文件，并获取其[[Q&amp;A#什么叫做文件的句柄|句柄]]outfd，再根据句柄通过fdopen函数拿到FILE* 指针out<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (input_file) &#123;</span><br><span class="line"></span><br><span class="line">   inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;</span><br><span class="line"></span><br><span class="line"> outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line"></span><br><span class="line"> outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br></pre></td></tr></table></figure>
通过fgets从inf中逐行读取内容保存到line数组里，每行最多读取的字节数是MAX_LINE(8192),这个值包括’\0’,所以实际读取的有内容的字节数是MAX_LINE-1个字节。从line数组里将读取的内容写入到outf对应的文件里<br>接下来是插桩的过程<br>首先来看需要在哪些地方进行插桩<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主函数入口点</span></span><br><span class="line">^main:      - function entry <span class="title function_">point</span> <span class="params">(always instrumented)</span></span><br><span class="line"><span class="comment">//GCC编译器的分支标签</span></span><br><span class="line">      ^.L0:       - GCC branch label</span><br><span class="line">      <span class="comment">//Clang编译器生成的分支标签，在Clang模式下</span></span><br><span class="line">      ^.LBB0_0:   - clang branch <span class="title function_">label</span> <span class="params">(but only in clang mode)</span></span><br><span class="line">      <span class="comment">//表示条件分支指令jnz</span></span><br><span class="line">      ^\tjnz foo  - conditional branches</span><br><span class="line"></span><br><span class="line">    ...but not:</span><br><span class="line"></span><br><span class="line">      ^# BB#0:    - clang comments</span><br><span class="line">      ^ # BB#0:   - ditto</span><br><span class="line">      ^.Ltmp0:    - clang non-branch labels</span><br><span class="line">      ^.LC0       - GCC non-branch labels</span><br><span class="line">      ^.LBB0_0:   - <span class="title function_">ditto</span> <span class="params">(when in GCC mode)</span></span><br><span class="line">      ^\tjmp foo  - non-conditional jumps</span><br></pre></td></tr></table></figure>
这些地方是源码中提到的，有些地方插而有些地方不插。<br>注意：插桩只向[[Q&amp;A#什么叫做二进制可执行文件的段，分别是什么|.text]]插<br>具体插桩逻辑有很多，细致的没怎么关注，但是大概围绕着上面的原则，进行字符串匹配即可：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp;</span><br><span class="line">    !skip_intel &amp;&amp;</span><br><span class="line">    !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"><span class="comment">//先检查并跳过一些标签，宏，注释等代码，判断当前行是否为汇编指令</span></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"><span class="comment">//fprintf就会在输出文件中插入相应的插桩代码</span></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"><span class="comment">//插桩计数器加1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
然后根据目的插桩位置，进行不同的字符串比较，如果是目的桩，则插入即可。<br>其实可以看出来，afl的插桩逻辑比较简单，就是通过汇编的前导命令来判断这是否是一个分支或者是函数，然后插桩。</li>
</ul>
<h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><ul>
<li>读取环境变量AFL_INST_RATIO的值，设置为inst_ratio_str</li>
<li>设置srandom的随机种子为<code>rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</code></li>
<li>设置环境变量AS_LOOP_ENV_VAR的值为1</li>
<li>读取环境变量[[Q&amp;A#什么是ASAN或MSAN|AFL_USE_ASAN和AFL_USE_MSAN]]的值，如果其中有一个为1，则设置sanitizer为1，且将inst_ratio除3。<ul>
<li>这是因为AFL无法在插桩的时候识别出ASAN specific branches，所以会插入很多无意义的桩，为了降低这种概率，粗暴的将整个插桩的概率都除以3</li>
</ul>
</li>
<li>edit_params(argc, argv)</li>
<li>add_instrumentation()</li>
<li>fork出一个子进程，让子进程来执行<code>execvp(as_params[0], (char **) as_params);</code><ul>
<li>这其实是因为我们的execvp执行的时候，会用<code>as_params[0]</code>来完全替换掉当前进程空间中的程序，如果不通过子进程来执行实际的as，那么后续就无法在执行完实际的as之后，还能unlink掉modified_file</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mickole/p/3187409.html">exec系列函数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/THEONE10211024/article/details/13774669">fork出的子进程和父进程</a></li>
</ul>
</li>
<li><code>waitpid(pid, &amp;status, 0)</code>等待子进程结束</li>
<li>读取环境变量AFL_KEEP_ASSEMBLY的值，如果没有设置这个环境变量，就unlink掉modified_file。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line"></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</span><br><span class="line"></span><br><span class="line">  srandom(rand_seed);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line"></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="afl-clang-fast"><a href="#afl-clang-fast" class="headerlink" title="afl-clang-fast"></a>afl-clang-fast</h1><p>先跳过</p>
<h1 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h1><p>该部分是AFL中最重要的部分，此为模糊器的实现部分。其主要作用是通过不断变异测试用例来影响程序的执行路径</p>
<p>在功能上，可以分为三部分：</p>
<ol>
<li>初始配置，</li>
<li>fuzz执行</li>
<li>变异策略</li>
</ol>
<p>该文件比较长，从main开始读，前半部分都在做参数解析的工作</p>
<h3 id="main-2"><a href="#main-2" class="headerlink" title="main"></a>main</h3><p>配置部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>7798-7989这一部分是从终端输入中匹配<br>7989-8091这一部分是一些配置，准备工作<br>先按照顺序来，再细讲各个函数：<br>调用<code>get_cur_time</code>获取开始时间，然后<code>perform_dry_run</code>生成初始化的<code>queue</code>和<code>bitmap</code>只对初始执行一次。</p>
<h3 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h3><p>该函数是AFL中的一个关键函数，他会执行input文件夹下预先准备的所有测试用例，生成初始化的<code>queue</code>和<code>bitmap</code>，只对初始执行一次。<br>函数执行的逻辑大致是：首先打开文件并读取测试用例，调用<code>calibrate_case</code>进行校准，然后根据res的结果进行处理，最后再统计输出。<br>该函数可以帮助用户了解测试集的质量和性能。</p>
<ol>
<li>读取环境变量</li>
<li>遍历<code>queue</code> <code>res=calibrate_case(argv,q,use_mem,0,1)</code>此为校准测试用例</li>
<li>根据res的结果进行判断：<ul>
<li>FAULT_NONE<ul>
<li>如果q是头结点，即第一个测试用例，则<code>check_map_coverage</code>，用以评估map coverage<ul>
<li>计数trace_bits发现的路径数，如果小于100，就直接返回</li>
<li>在trace_bits的数组后半段，如果有值就直接返回。</li>
<li>抛出警告<code>WARNF(&quot;Recompile binary with newer version of afl to improve coverage!&quot;)</code></li>
</ul>
</li>
<li>如果是crash_mode，则抛出异常，<code>FATAL(&quot;Test case &#39;%s&#39; does *NOT* crash&quot;, fn);</code>，该文件不崩溃</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>FAULT_TMOUT<ul>
<li>如果指定了-t参数，则timeout_given值为2<ul>
<li>抛出警告<code>WARNF(&quot;Test case results in a timeout (skipping)&quot;);</code>，并设置q的cal_failed为CAL_CHANCES，cal_failures计数器加一。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>如果没有指定mem_limit，则可能抛出建议增加内存的建议</li>
<li>但不管指定了还是没有，都会抛出异常<code>FATAL(&quot;Test case &#39;%s&#39; results in a crash&quot;, fn);</code></li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常<code>Unable to execute target application</code></li>
</ul>
</li>
<li>FAULT_NOINST<ul>
<li>这个样例运行没有出现任何路径信息，抛出异常<code>No instrumentation detected</code></li>
</ul>
</li>
<li>FAULT_NOBITS<ul>
<li>如果这个样例有出现路径信息，但是没有任何新路径，抛出警告<code>WARNF(&quot;No new instrumentation output, test case may be useless.&quot;)</code>，认为这是无用路径。useless_at_start计数器加一</li>
</ul>
</li>
<li>如果这个样例q的var_behavior为真，则代表它多次运行，同样的输入条件下，却出现不同的覆盖信息。</li>
<li>抛出警告<code>WARNF(&quot;Instrumentation output varies across runs.&quot;);</code>，代表这个样例的路径输出可变</li>
<li>然后读取下一个queue，继续测试，直到结束。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">perform_dry_run</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  u8* skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line"></span><br><span class="line">    u8* use_mem;</span><br><span class="line">    u8  res;</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">      FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ck_free(use_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST,</span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NONE:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="built_in">queue</span>) check_map_coverage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; does *NOT* crash&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line">      <span class="keyword">if</span> (timeout_given &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            WARNF(<span class="string">&quot;Test case results in a timeout (skipping)&quot;</span>);</span><br><span class="line">            q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">            cal_failures++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_crashes) &#123;</span><br><span class="line">          WARNF(<span class="string">&quot;Test case results in a crash (skipping)&quot;</span>);</span><br><span class="line">          q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">          cal_failures++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> FAULT_ERROR:</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NOINST:</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;No instrumentation detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NOBITS:</span><br><span class="line"></span><br><span class="line">        useless_at_start++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_bitmap &amp;&amp; !shuffle_queue)</span><br><span class="line">          WARNF(<span class="string">&quot;No new instrumentation output, test case may be useless.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;var_behavior) WARNF(<span class="string">&quot;Instrumentation output varies across runs.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cal_failures) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cal_failures == queued_paths)</span><br><span class="line">      FATAL(<span class="string">&quot;All test cases time out%s, giving up!&quot;</span>,</span><br><span class="line">            skip_crashes ? <span class="string">&quot; or crash&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WARNF(<span class="string">&quot;Skipped %u test cases (%0.02f%%) due to timeouts%s.&quot;</span>, cal_failures,</span><br><span class="line">          ((<span class="type">double</span>)cal_failures) * <span class="number">100</span> / queued_paths,</span><br><span class="line">          skip_crashes ? <span class="string">&quot; or crashes&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cal_failures * <span class="number">5</span> &gt; queued_paths)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;High percentage of rejected test cases, check settings!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h3><p>该函数用于新测试用例的校准，在处理输入目录时执行。<br>该函数的主要用途是初始化并启动fork server</p>
<h3 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h3><p>每当我们发现一个新的路径，就需要判断发现的路径是否更”favorable”，也就是说是否包含更小的路径集合，能遍历到所有[[Q&amp;A#fuzz所维护的bitmap|bitmap]]的位，并在fuzz的过程中聚焦在这些路径上<br>以上过程的第一步是为bitmap中的每个字节维护一个<code>top_rated[]</code>的列表，这里会计算究竟哪些位置是更“合适”的，该函数主要实现该过程。</p>
<p>该函数的参数是一个测试用例，首先先根据执行时间和文件长度决定<code>fav_factor</code>也就是权重。然后遍历<code>bitmap</code>，如果<code>trace_bit[i]==1</code>即该代码块被执行过则考察<code>top_rated[]</code>比较当前的权重和已有的权重，如果<code>top_rated[]</code>的权重更小，则意味着原值更优，否则反之，更新即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_bitmap_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;<span class="comment">//执行时间和文件大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len) <span class="keyword">continue</span>;<span class="comment">//原值更优不更新</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">            previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;</span><br><span class="line">           ck_free(top_rated[i]-&gt;trace_mini);</span><br><span class="line">           top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"></span><br><span class="line">       top_rated[i] = q;<span class="comment">//当前值更优，更新。</span></span><br><span class="line">       q-&gt;tc_ref++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">         q-&gt;trace_mini = ck_alloc(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         minimize_bits(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       score_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fuzz执行"><a href="#fuzz执行" class="headerlink" title="fuzz执行"></a>fuzz执行</h2><p>主循环在8091开始<br>分三个部分，主循环前，主循环中，主循环后</p>
<h3 id="cull-queue-主循环前"><a href="#cull-queue-主循环前" class="headerlink" title="cull_queue(主循环前)"></a>cull_queue(主循环前)</h3><p>根据当前的<code>bitmap</code>的信息，标记哪些测试用例是有利的，哪些是冗余的。然后尽量剔除冗余的，留下有利的。换句话说就是：精简队列。</p>
<ul>
<li>如果score_changed为0，即top_rated没有变化，或者dumb_mode,就直接返回</li>
<li>设置score_changed的值为0</li>
<li>创建u8 temp_v数组，大小为<code>MAP_SIZE除8</code>，并将其初始值设置为0xff，其每位如果为1就代表还没有被覆盖到，如果为0就代表以及被覆盖到了。</li>
<li>设置queued_favored为0，pending_favored为0</li>
<li>开始遍历queue队列，设置其favored的值都为0</li>
<li>将i从0到MAP_SIZE迭代，这个迭代其实就是筛选出一组queue entry，它们就能够覆盖到所有现在已经覆盖到的路径，而且这个case集合里的case要更小更快，这并不是最优算法，只能算是贪婪算法。<ul>
<li>这又是个不好懂的位运算，<code>temp_v[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))</code>与上面的差不多，中间的或运算改成了与，是为了检查该位是不是0，即判断该path对应的bit有没有被置位。</li>
</ul>
</li>
<li>如果<code>top_rated[i]</code>有值，且该path在temp_v里被置位<ul>
<li>就从temp_v中清除掉所有<code>top_rated[i]</code>覆盖到的path，将对应的bit置为0</li>
<li>设置<code>top_rated[i]-&gt;favored</code>为1，queued_favored计数器加一</li>
<li>如果<code>top_rated[i]</code>的was_fuzzed字段是0，代表其还没有fuzz过，则将pending_favored计数器加一</li>
</ul>
</li>
<li>遍历queue队列<ul>
<li>mark_as_redundant(q, !q-&gt;favored)<ul>
<li>也就是说，如果不是favored的case，就被标记成redundant_edges</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cull_queue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span>;</span></span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line"></span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line"></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    mark_as_redundant(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子更好理解：<br>现假设有如下tuple和seed信息：</p>
<ul>
<li><strong>tuple</strong>: t0, t1, t2, t3, t4</li>
<li><strong>seed</strong>: s0, s1, s2</li>
<li>初始化<code>temp_v = [1,1,1,1,1]</code></li>
<li>s1可覆盖t2, t3，s2覆盖t0, t1, t4，并且top_rated[0] &#x3D; s2，top_rated[2]&#x3D;s1<br>将按照如下过程进行筛选和判断：</li>
</ul>
<ol>
<li>首先判断 temp_v[0]&#x3D;1，说明t0没有被覆盖；</li>
<li>top_rated[0] 存在 (s2) -&gt; 判断s2可以覆盖的范围 -&gt;<code>trace_mini = [1,1,0,0,1]</code>；</li>
<li>更新<code>temp_v=[0,0,1,1,0]</code>， 标记s2为 “favored”；</li>
<li>继续判断 temp_v[1]&#x3D;0，说明t1此时已经被覆盖，跳过；</li>
<li>继续判断 temp_v[2]&#x3D;1，说明t2没有被覆盖；</li>
<li>top_rated[2] 存在 (s1) -&gt; 判断s1可以覆盖的范围 -&gt;<code>trace_mini=[0,0,1,1,0]</code>；</li>
<li>更新<code>temp_v=[0,0,0,0,0]</code>，标记s1为 “favored”；</li>
<li>此时所有tuple都被覆盖，具备”favored’标记的为s1, s2，过程结束。</li>
</ol>
<h3 id="主循环-8091"><a href="#主循环-8091" class="headerlink" title="主循环(8091)"></a>主循环(8091)</h3><p>主循环所作的事情就是变异，执行测试用例，评估测试结果，和更新队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">   u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">   cull_queue();<span class="comment">//先精简队列</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!queue_cur) &#123;<span class="comment">//这一部分是队列处理，如果已经做完一轮</span></span><br><span class="line"></span><br><span class="line">     queue_cycle++;<span class="comment">//轮数++</span></span><br><span class="line">     current_entry     = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">     queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (seek_to) &#123;<span class="comment">//将cur指针指到队列中的具体位置。</span></span><br><span class="line">       current_entry++;</span><br><span class="line">       seek_to--;</span><br><span class="line">       queue_cur = queue_cur-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     show_stats();<span class="comment">//显示fuzzing的进度，不是逻辑部分</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (not_on_tty) &#123;<span class="comment">//非终端模式时，不是逻辑部分</span></span><br><span class="line">       ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">       fflush(<span class="built_in">stdout</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">        recombination strategies next. */</span></span><br><span class="line">  <span class="comment">//使用recombination策略</span></span><br><span class="line">     <span class="keyword">if</span> (queued_paths == prev_queued) &#123;<span class="comment">//循环计数，完整跑了一次而没有新路径</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">       sync_fuzzers(use_argv);<span class="comment">//同步操作</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//该函数从队列中选择一个测试用例进行变异和执行。</span></span><br><span class="line">   skipped_fuzz = fuzz_one(use_argv);<span class="comment">//进行一次模糊测试</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;<span class="comment">//再次同步</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">       sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;<span class="comment">//stop</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   queue_cur = queue_cur-&gt;next;<span class="comment">//更新队列指针</span></span><br><span class="line">   current_entry++;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其实可以通过源码看出来，主循环的逻辑其实还算简洁。</p>
<h3 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h3><p>该函数是执行，变异的关键函数。也是最重要的函数。5003-6690<br>在这里，需要结合[[白皮书#5. 模糊测试策略（变异策略）|白皮书上的变异策略来看]]，两大种变异策略，确定性和非确定性。<br>将这大型函数分治来看，前半部分是准备，后半部分才是变异处理。<br>前半部分：</p>
<ol>
<li>根据不同的情况，对当前测试用例有概率直接返回（个人理解应该是为了加速）根据是否有<code>pending_favored</code>和<code>queue_cur</code>的情况，按照概率进行跳过；有<code>pending_favored</code>, 对于已经fuzz过的或者non-favored的有99%的概率跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored；<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pending_favored) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span></span><br><span class="line"><span class="comment">     possibly skip to them at the expense of already-fuzzed or non-favored</span></span><br><span class="line"><span class="comment">     cases. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">      UR(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span></span><br><span class="line"><span class="comment">     The odds of skipping stuff are higher for already-fuzzed inputs and</span></span><br><span class="line"><span class="comment">     lower for never-fuzzed entries. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用于初始化测试用例和进行一些准备工作。不是逻辑重点不贴代码</li>
<li>处理测试用例在校准阶段失败的情况，通过重置 <code>exec_cksum</code> 重新执行测试用例，避免使用无效的 <code>trace_bits</code> 进行模糊测试<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue_cur-&gt;cal_failed) &#123;</span><br><span class="line"></span><br><span class="line">  u8 res = FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;cal_failed &lt; CAL_CHANCES) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset exec_cksum to tell calibrate_case to re-execute the testcase</span></span><br><span class="line"><span class="comment">       avoiding the usage of an invalid trace_bits.</span></span><br><span class="line"><span class="comment">       For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */</span></span><br><span class="line"></span><br><span class="line">    queue_cur-&gt;exec_cksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon || res != crash_mode) &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对测试用例进行修剪，调用<code>trim_case</code>函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123;</span><br><span class="line"></span><br><span class="line">  u8 res = trim_case(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">  queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len != queue_cur-&gt;len) len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对测试用例进行打分，调用<code>calculate_score</code>函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">orig_perf = perf_score = calculate_score(queue_cur);</span><br><span class="line"><span class="comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on this entry ourselves (was_fuzzed), or if it has gone through deterministic testing in earlier, resumed runs (passed_det). */</span></span><br><span class="line"><span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope for this master instance. */</span></span><br><span class="line"><span class="comment">//如果已经完成了deterministic阶段，则直接进行havoc</span></span><br><span class="line"><span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">doing_det = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>至此，前半部分的准备工作已经完成，下面开始进行变异。</p>
<ul>
<li><strong>SIMPLE BITFLIP (+dictionary construction)阶段</strong>，按位翻转，根据翻转量&#x2F;步长，按位翻转的策略有以下几种<br>bitflip 1&#x2F;1，每次翻转1个bit，按照每1个bit的步长从头开始<br>bitflip 2&#x2F;1，每次翻转相邻的2个bit，按照每1个bit的步长从头开始<br>bitflip 4&#x2F;1，每次翻转相邻的4个bit，按照每1个bit的步长从头开始<br>bitflip 8&#x2F;8，每次翻转相邻的8个bit，按照每8个bit的步长从头开始，即依次对每个byte做翻转<br>bitflip 16&#x2F;8，每次翻转相邻的16个bit，按照每8个bit的步长从头开始，即依次对每个word做翻转<br>bitflip 32&#x2F;8，每次翻转相邻的32个bit，按照每8个bit的步长从头开始，即依次对每个dword做翻转</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">define <span class="title function_">FLIP_BIT</span><span class="params">(_ar, _b)</span> <span class="keyword">do</span> &#123; \ <span class="comment">//这个函数是翻转特定位的bit</span></span><br><span class="line">    u8* _arf = (u8*)(_ar); \</span><br><span class="line">    u32 _bf = (_b); \</span><br><span class="line">    _arf[(_bf) &gt;&gt; <span class="number">3</span>] ^= (<span class="number">128</span> &gt;&gt; ((_bf) &amp; <span class="number">7</span>)); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  stage_short = <span class="string">&quot;flip1&quot;</span>;<span class="comment">//当前变异阶段的简称</span></span><br><span class="line">  stage_max   = len &lt;&lt; <span class="number">3</span>;<span class="comment">//变异的次数</span></span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 1/1&quot;</span>;<span class="comment">//名称</span></span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;<span class="comment">//遍历位</span></span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;<span class="comment">//当前步数转换位字节索引</span></span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);<span class="comment">//翻转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);<span class="comment">//恢复</span></span><br></pre></td></tr></table></figure>
<p>在bitflip1&#x2F;1中还有一部分是实现寻找token</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;<span class="comment">//每翻转八次进入该阶段</span></span><br><span class="line"></span><br><span class="line">      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);<span class="comment">//计算trace校验和</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;<span class="comment">//如果抵达文件末尾但是校验和没有发生改变</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">           final character and force output. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">           worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)<span class="comment">//如果按位翻转实际上改变了校验和即执行路径发生变化</span></span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">        a_len = <span class="number">0</span>;</span><br><span class="line">        prev_cksum = cksum;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">         any difference - we don&#x27;t want no-op tokens. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一部分就是AFL尝试去猜解token，有着一定启发式。<br>在进行bitflip 1&#x2F;1变异时，对于每个byte(因为每一个byte都是八位，所以代码上是每八位处理一次)的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。这里用路径的hash来判断是否改变。<br>例如，PNG文件中用IHDR作为起始块的标识，那么就会存在类似于以下的内容<br>…IHDR…<br>在执行 bitflip 1&#x2F;1 时，如果连续翻转多个字节后的用例，都能让程序走到新的代码路径，那么就称连续翻转的字节是一个 token。<br>当翻转到字符I的最高位时，因为IHDR被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，IHDR标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：IHDR，并将其记录下来为后面的变异提供备选。<br>后面的<code>bitflip2/1、4/1、1/1</code>是同理的。</p>
<p>不过值得注意的是，AFL在<code>bitflip8/8</code>这里维护了一个<code>eff_map</code>，这个<code>eff_map</code>是启发式的一个map，是精髓所在。具体含义是：在对每个<code>byte</code>进行翻转时，如果其造成执行路径与源路径不一致，则将该<code>byte</code>在<code>eff_map</code>中标记。这是因为：如果一个<code>byte</code>完全翻转都不能产生路径变化，则这个<code>byte</code>有可能是”data”，对整个fuzzing意义不大，在之后的确定性变异中，会参考<code>eff_map</code>跳过无效的变异，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!eff_map[EFF_APOS(stage_cur)]) &#123;</span><br><span class="line"></span><br><span class="line">  u32 cksum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If in dumb mode or if the file is very short, just flag everything</span></span><br><span class="line"><span class="comment">     without wasting time on checksums. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)</span><br><span class="line">    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cksum = ~queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line">    eff_map[EFF_APOS(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">    eff_cnt++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ARITHMETIC INC&#x2F;DEC</strong>阶段，整数加减运算<br>bitflip 结束之后，就进入 arithmetic 阶段，目标大小和阶段与 bitflip 非常类似：</li>
</ul>
<p>arith 8&#x2F;8，每次8bit进行加减运算，8bit步长从头开始，即对每个byte进行整数加减变异；<br>arith 16&#x2F;8，每次16bit进行加减运算，8bit步长从头开始，即对每个word进行整数加减变异；<br>arith 32&#x2F;8，每次32bit进行加减运算，8bit步长从头开始，即对每个dword进行整数加减变异；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;arith 8/8&quot;</span>;<span class="comment">//8比特的算术变异</span></span><br><span class="line">stage_short = <span class="string">&quot;arith8&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = <span class="number">2</span> * len * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;<span class="comment">//当前路径计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//遍历每个字节</span></span><br><span class="line"></span><br><span class="line">  u8 orig = out_buf[i];<span class="comment">//保留字节的原始值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;<span class="comment">//当前字节不再有效影响范围内</span></span><br><span class="line">  <span class="comment">//智能跳过某些变异：如果一个整数的所有bytes都被判断为无效，则跳过。</span></span><br><span class="line">    stage_max -= <span class="number">2</span> * ARITH_MAX;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">    u8 r = orig ^ (orig + j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do arithmetic operations only if the result couldn&#x27;t be a product</span></span><br><span class="line"><span class="comment">       of a bitflip. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;<span class="comment">//如果结果不可能是比特翻转的产物，即不会产生无效的变异，就进行处理</span></span><br><span class="line"><span class="comment">//智能跳过之前翻转发生的变异</span></span><br><span class="line">      stage_cur_val = j;<span class="comment">//记录变异的值</span></span><br><span class="line">      out_buf[i] = orig + j;<span class="comment">//变异</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    r =  orig ^ (orig - j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">      stage_cur_val = -j;</span><br><span class="line">      out_buf[i] = orig - j;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    out_buf[i] = orig;<span class="comment">//还原</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;<span class="comment">//记录新的路径计数</span></span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;<span class="comment">//记录当前阶段发现的路径数量</span></span><br><span class="line">stage_cycles[STAGE_ARITH8] += stage_max;<span class="comment">//记录当前阶段处理总次数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>INTERESTING VALUES</strong>阶段<br>这个”interesting”代表着一些特殊值<br>不过这个部分的代码比较简单，就只是将部分替换成预设的”interesting”部分。<br>其中要跳过<code>eff_map</code>的以及之前变异过的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;interest 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;int8&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len * <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setting 8-bit integers. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">    stage_max -= <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_8); j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip if the value could be a product of bitflips or arithmetics. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">        could_be_arith(orig, (u8)interesting_8[j], <span class="number">1</span>)) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_val = interesting_8[j];</span><br><span class="line">    out_buf[i] = interesting_8[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    out_buf[i] = orig;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_INTEREST8] += stage_max;</span><br></pre></td></tr></table></figure></li>
<li><strong>DICTIONARY STUFF</strong>阶段<br>该阶段是确定性变异的尾声，如果用户提供的字典里有<code>token</code>则替换变异文件，如果没有则使用<code>bitflip</code>产生的<code>token</code><br>该阶段分三小阶段：</li>
</ul>
<ol>
<li>user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中。对于用户提供的<code>token</code>，AFL会从小到大的排，这样在替换的时候后面的<code>token</code>不会比前面的短，省去了还原的步骤。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;user extras (over)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_UO&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = extras_cnt * len;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Extras are sorted by size, from smallest to largest. This means</span></span><br><span class="line"><span class="comment">     that we don&#x27;t have to worry about restoring the buffer in</span></span><br><span class="line"><span class="comment">     between writes at a particular offset determined by the outer</span></span><br><span class="line"><span class="comment">     loop. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;<span class="comment">//遍历用户token</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also</span></span><br><span class="line"><span class="comment">       skip them if there&#x27;s no room to insert the payload, if the token</span></span><br><span class="line"><span class="comment">       is redundant, or if its entire span has no bytes set in the effector</span></span><br><span class="line"><span class="comment">       map. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;= MAX_DET_EXTRAS) ||</span><br><span class="line">        extras[j].len &gt; len - i ||</span><br><span class="line">        !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">        !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, extras[j].len))) &#123;<span class="comment">//如果Token数量太多，就需要根据这些条件进行有概率的跳过</span></span><br><span class="line"></span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_len = extras[j].len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br></pre></td></tr></table></figure></li>
<li>user extras (insert)，user extras (insert)是对用户提供的tokens执行插入变异，与user extras (over)不同，由于原文件并未发生替换，effector map在这里不再被使用了。并且此时并没有对tokens数量的限制，所以全部tokens都会从原文件的第1个byte开始，依次向后插入。这一子阶段最特别的地方，就是变异不能简单地恢复。之前每次变异完，在变异位置处简单取逆即可，例如bitflip后，再进行一次同样的bitflip就恢复为原文件。正因为如此，之前的变异总体运算量并不大。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;user extras (insert)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_UI&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = extras_cnt * (len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">ex_tmp = ck_alloc(len + MAX_DICT_FILE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len + extras[j].len &gt; MAX_FILE) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Insert token */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ex_tmp + i, extras[j].data, extras[j].len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy tail */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ex_tmp + i + extras[j].len, out_buf + i, len - i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) &#123;</span><br><span class="line">      ck_free(ex_tmp);</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Copy head */</span></span><br><span class="line">  ex_tmp[i] = out_buf[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ck_free(ex_tmp);</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_UI] += stage_max;</span><br></pre></td></tr></table></figure></li>
<li>auto extras (over),这一项与”user extras (over)”很类似，区别在于，这里的tokens是最开始bitflip阶段自动生成的。另外，自动生成的tokens总量会由USE_AUTO_EXTRAS限制（默认为128）。代码就不贴了<br>至此，确定性变异就结束了，下面开始非确定性变异。</li>
</ol>
<ul>
<li><strong>HAVOC</strong>阶段<br>havoc英文释义是”混沌“，在这里havoc，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成。<br>在这一阶段中，共有十六种随机变异。事实上，havoc会对原文件进行多轮变异，每一轮都是多种方式组合。代码不全贴。AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了</li>
<li><strong>SPLICING</strong>阶段<br>此为最后的阶段，是将两个seed拼接得到新的文件，对这个新文件继续进行havoc变异。<br>具体地，AFL在seed文件队列中随机选取一个，与当前的seed文件做对比。<br><code>if (f_diff &lt; 0 || l_diff &lt; 2 || f_diff == l_diff) &#123; goto retry_splicing; &#125;</code>如果两者差别不大，就再重新随机选一个；如果两者相差比较明显，那么就随机选取一个位置，<code>split_at = f_diff + rand_below(afl, l_diff - f_diff);</code>将两者都分割为头部和尾部。最后，将当前文件的头部与随机文件的尾部拼接起来，就得到了新的文件。在这里，AFL还会过滤掉拼接文件未发生变化的情况。</li>
</ul>
<p>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。</p>
<p>那么到这里，fuzz.c文件的整体框架和逻辑就这么多了。有些通信上的细节可能还没弄完全，但是大部分内容是差不多了。<br>总结来说，AFL基于变异的模糊测试器，它的逻辑还算比较清楚明朗，源码的构成也相对清楚。不过这次还没看完llvm模式下的插桩，之后再看吧。看源码进行学习确实事半功倍，经验就是跟着主函数执行的过程一步步的拆解代码，分析过程，考察关键函数就行。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/AFL/" rel="tag"># AFL</a>
              <a href="/tags/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/" rel="tag"># 模糊测试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/01/AFL%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84Q-A/" rel="prev" title="AFL学习中的Q&A">
      <i class="fa fa-chevron-left"></i> AFL学习中的Q&A
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/04/peach%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/" rel="next" title="peach原理和使用">
      peach原理和使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#afl-gcc-c"><span class="nav-number">1.</span> <span class="nav-text">afl-gcc.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#find-as"><span class="nav-number">1.0.1.</span> <span class="nav-text">find_as</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params"><span class="nav-number">1.0.2.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main"><span class="nav-number">1.0.3.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params-1"><span class="nav-number">1.0.4.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-instructmentation"><span class="nav-number">1.0.5.</span> <span class="nav-text">add_instructmentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-1"><span class="nav-number">1.0.6.</span> <span class="nav-text">main</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#afl-clang-fast"><span class="nav-number">2.</span> <span class="nav-text">afl-clang-fast</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#afl-fuzz-c"><span class="nav-number">3.</span> <span class="nav-text">afl-fuzz.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#main-2"><span class="nav-number">3.0.1.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perform-dry-run"><span class="nav-number">3.0.2.</span> <span class="nav-text">perform_dry_run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#calibrate-case"><span class="nav-number">3.0.3.</span> <span class="nav-text">calibrate_case</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update-bitmap-score"><span class="nav-number">3.0.4.</span> <span class="nav-text">update_bitmap_score</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzz%E6%89%A7%E8%A1%8C"><span class="nav-number">3.1.</span> <span class="nav-text">fuzz执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cull-queue-%E4%B8%BB%E5%BE%AA%E7%8E%AF%E5%89%8D"><span class="nav-number">3.1.1.</span> <span class="nav-text">cull_queue(主循环前)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%BE%AA%E7%8E%AF-8091"><span class="nav-number">3.1.2.</span> <span class="nav-text">主循环(8091)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzz-one"><span class="nav-number">3.1.3.</span> <span class="nav-text">fuzz_one</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparrow"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparrow</p>
  <div class="site-description" itemprop="description">不知所措才是人生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huamuyichun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huamuyichun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2486013181@qq.com" title="E-Mail → mailto:2486013181@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/hejiawenze" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;hejiawenze" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-04 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sparrow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共31.7k字</span>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

  

</body>
</html>
